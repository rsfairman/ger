package vcnc.tpile;

/*

The broadest type of statement, as generated by the Parser. Layer0A also
emits these.

These names are a little unfortunate, but it seems better than something
longer, like StatementxP or StatementParser. It's typed a lot.

The general "statement type" is built from a series of layers, in parallel with
the translation layers. The reason to do this is to give each layer a
distinct type for the statements produced by that layer. This makes the set
of permitted types of statements (G00, G01, etc.) clear, and allows enforcing
the elimination of different types of statements as the translation proceeds.
The goal is to make it impossible (i.e., the compiler will catch it) to
refer to any statement type that shouldn't be possible in a given layer.

If Java allowed one to extend the enum type, that might be a cleaner way to do
this, but Java doesn't. So we have to specify the distinct enumerable values 
explicitly, while being careful not to reuse integer values. That's far from 
ideal and requires careful attention to how these classes are defined, but 
seems worth the trade-off.  Another unfortunate thing is that there is no
single file where all acceptable G-codes are listed; you need to look at
each of the extensions of the base class.

To keep the use of integers straight, the values used by each layer are limited
to a certain range of 1,000, like 0-999 or 12,000-12,999.

Another unfortunate/confusing thing is the order of the names used for these
layers of statement types. St01 (say) consists of those things that Layer01
might generate. So, it should included definitions of constants for the 
statements that Layer01 might generate but that Layer02 will consume and 
*not* generate. It might be better to reorder the naming so that St01 
corresponds to what Layer01 consumes instead of what it generates. It depends
on which end of the pipe you look through.

In any case, this thing isn't perfect. The way it's used, there's a lot of
casting up and down the super/sub-class chain. At run-time, you will often
be using an object of type StxP (say) even in the final layer. Because
the only real difference between the classes is which constants are defined
for which G-codes, that's OK. The compiler should still catch the stupid 
mistakes I'm worried about. To make it "type-tight," the thing to do would be
to provide each sub-class with a factory that allocates an entirely new
object for the super-class. But then you'd be doing a huge amount of copying
for no good reason. 

So, although this particular method of defining layers of statement types
is not pretty, it does get the job done. Switching to this framework (in v08
and v09, roughly) made the code that does the actual G-code translation
clearer and cleaner, and helped to find various small oversights.

*/

import vcnc.tpile.parse.DataWizard;


public class StxP extends St0B {

  // This is used to make things a little simpler to allocate these objects 
  // before we know their type. Otherwise you need a do-nothing constructor.
  // It should never be used, except momentarily.
  public static final short UNKNOWN = 1000;
  
  // The only kind of statement generated by the Parser and *not* generated
  // by Layer0B:
  public static final short WIZARD = 1001;
  
  
  
  public StxP(short type) {
    super(type);
  }

  public String toString() {
    
    // The only type known here and not to a super-class:
    if (this.type == WIZARD)
      {
        DataWizard wiz = (DataWizard) this.data;
        String answer = wiz.cmd;
        for (int i = 0; i < wiz.args.size(); i++)
          {
            Object o = wiz.args.get(i);
            if (o instanceof Double)
              answer += " " + (Double) o;
            else if (o instanceof String)
              answer += " \"" + (String) o + "\"";
            else
              // Should be impossible.
              answer += " unknown weirdness";
          }
        
        return answer;
      } 
    
    // Got here. so the statement type must belong to a super-class.
    return super.toString();
  }
  
}



